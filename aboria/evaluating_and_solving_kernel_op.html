<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Evaluating and Solving Kernel Operators with Eigen</title>
<link rel="stylesheet" href="../css/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Aboria 0.5">
<link rel="up" href="../index.html" title="Aboria 0.5">
<link rel="prev" href="neighbourhood_searching.html" title="Neighbourhood Searching">
<link rel="next" href="symbolic_expressions.html" title="Symbolic Expressions">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
    },
  TeX: { 
    extensions: ["AMSmath.js", "AMSsymbols.js"] 
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48149829-4', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Aboria" width="200" height="62" src="../images/aboria2.jpg"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="neighbourhood_searching.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="symbolic_expressions.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="aboria.evaluating_and_solving_kernel_op"></a><a class="link" href="evaluating_and_solving_kernel_op.html" title="Evaluating and Solving Kernel Operators with Eigen">Evaluating and
    Solving Kernel Operators with Eigen</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_dense_operators">Creating
      Dense Operators</a></span></dt>
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_sparse_operators">Creating
      Sparse Operators</a></span></dt>
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_chebyshev_operators">Creating
      Chebyshev Operators</a></span></dt>
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_fast_multipole_method_o">Creating
      Fast Multipole Method Operators</a></span></dt>
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_hierarchical_matrix_ope">Creating
      Hierarchical Matrix Operators</a></span></dt>
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.block_operators">Block
      Operators</a></span></dt>
<dt><span class="section"><a href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.iterative_solvers">Iterative
      Solvers</a></span></dt>
</dl></div>
<p>
      Given that Aboria can describe non-linear operators, this naturally covers
      linear operators (i.e. matrices) as well. Consider the summation operator given
      by the kernel function $K(x_i,x_j)$, over a set of $N$ particles
    </p>
<p>
      $$ a_i = \sum_j^N b_j K(x_i,x_j) \text{ for } i=1..N $$
    </p>
<p>
      This is a common enough operator that can be used in many areas. If $K(x_i,x_j)
      = 1/(x_j-x_i)$, then the operator might be calculating the force on a set of
      charged particles via a Coulomb force. If $K(x_i,x_j) = \sqrt{(x_j-x_i)^2 +
      c^2}$, then the operator might be used for function interpolation using the
      multiquadric basis function.
    </p>
<p>
      One way to evaluate this operator is to use a matrix to store the values of
      $K(x_i,x_j)$ for each particle pair, leading to a matrix $\mathbf{K}$ with
      storage size $N^2$. Then the summation operator above is equivalent to the
      matrix-vector product
    </p>
<p>
      $$ \mathbf{a} = \mathbf{K} \mathbf{b}. $$
    </p>
<p>
      However, $\mathbf{K}$ could be too large to fit in memory, or the values of
      $x_i$ and $x_j$ might change too frequently for this to be useful. Or you may
      wish to take advantage of the fact that $K(x_i,x_j)$ is a continuous function
      and use method such as Chebyshev interpolation or Fast Multipole methods to
      efficiently calculate the action of the operator on the vector $\mathbf{b}$.
      For any of these reasons and many others, Aboria can help you out.
    </p>
<p>
      Aboria provides functionality to describe linear operators arising from the
      evaluation of kernel functions at a set of points (i.e. particles in Aboria's
      terminology) in $N$ dimensional space. From now on we will refer to these types
      of operators as <span class="bold"><strong>kernel operators</strong></span>. To provide
      the concept and API of a matrix or linear operator, we will use the C++ linear
      algebra library <a href="../eigen.tuxfamily.org" target="_top">Eigen</a>. Aboria provides
      functionality to wrap kernel operators as <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html" title="Class template MatrixReplacement">Aboria::MatrixReplacement</a></code>,
      so that Eigen can treat them as normal dense or sparse matrices.
    </p>
<p>
      Using this wrapping, we can take advantage of Eigen to:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          calculate the action of a kernel operator on a vector (i.e. a matrix-vector
          multiplication)
        </li>
<li class="listitem">
          use Eigen's iterative solvers to solve a large linear system of equations
          arising from a kernel operator.
        </li>
</ol></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.creating_dense_operators"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_dense_operators" title="Creating Dense Operators">Creating
      Dense Operators</a>
</h3></div></div></div>
<p>
        The most general case involves a kernel operator $K$ that is non-zero for
        every possible particle pair. The kernel function can depend on the particle
        positions and/or the variables assigned to each particle. For example, say
        we had a particle set with particle positions $\mathbf{x}_i$ for $i=1..N$,
        and a single variable $a_i$. We wish to create a summation operator using
        the kernel function
      </p>
<p>
        $$ K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) = \frac{a_i a_j}{||\mathbf{x}_j-\mathbf{x}_i||
        + \epsilon} $$
      </p>
<p>
        were $||.||$ refers to the 2-norm, or magnitude of a vector.
      </p>
<p>
        First we need a particle set to apply the operator to. We will create a particle
        set containing $N=100$ particles with a single additional variable $a$.
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">N</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>
<span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">epsilon</span> <span class="special">=</span> <span class="number">0.1</span><span class="special">;</span>
<span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span><span class="keyword">double</span><span class="special">,</span><span class="string">"a"</span><span class="special">);</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;&gt;</span> <span class="identifier">particle_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">position</span> <span class="identifier">position</span><span class="special">;</span>
<span class="identifier">particle_type</span> <span class="identifier">particles</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">default_random_engine</span> <span class="identifier">gen</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">uniform_real_distribution</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">uniform</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">double3</span><span class="special">(</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">));</span>
    <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        For convenience, we will also define a few types that we will need to define
        our kernel function. These will define a constant reference to the storage
        type used to store each particle positions, and a constant reference type
        to refer to each particle in the container
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">position</span><span class="special">::</span><span class="identifier">value_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">const_position_reference</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">const_reference</span> <span class="identifier">const_particle_reference</span><span class="special">;</span>
</pre>
<p>
        We then create a dense kernel operator using the <code class="computeroutput"><a class="link" href="../Aboria/create_dense_operator.html" title="Function template create_dense_operator">Aboria::create_dense_operator</a></code>
        function
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">K</span> <span class="special">=</span> <span class="identifier">create_dense_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">i</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">(</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">j</span><span class="special">))</span> <span class="special">/</span> <span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        Note that <code class="computeroutput"><a class="link" href="../Aboria/create_dense_operator.html" title="Function template create_dense_operator">Aboria::create_dense_operator</a></code>
        takes three arguments. The first two are particle containers which give the
        two particle sets involved in the operator. The first container holds the
        particles indexed by $i$ in the kernel function, and the second holds the
        particles indexed by $j$. For a matrix representation, you might say that
        these refer to the rows and columns of the matrix.
      </p>
<p>
        The third argument to <code class="computeroutput"><a class="link" href="../Aboria/create_dense_operator.html" title="Function template create_dense_operator">Aboria::create_dense_operator</a></code>
        can be a function object, or C++ lambda expression. Basically any valid C++
        object that can be called with three arguments, the first being of type
        <code class="computeroutput"><span class="identifier">const_position_reference</span></code>
        (i.e. a constant reference to the position type), the second of type <code class="computeroutput"><span class="identifier">const_particle_reference</span></code> (i.e. a constant
        reference to a particle in the set indexed by $i$), and the third of type
        <code class="computeroutput"><span class="identifier">const_particle_reference</span></code>
        (i.e. a constant reference to a particle in the set indexed by $j$). The
        first argument will contain the shortest vector between the particle pair
        given by $i,j$, and the second and third will be references to the particles
        $i$ and $j$. Note that in this case the particle sets indexed by $i$ and
        $j$ is the same particle set <code class="computeroutput"><span class="identifier">particles</span></code>.
        However, in other cases you may want $i$ and $j$ to index different particle
        sets, in which case the types for argument 2 and 3 could be different.
      </p>
<p>
        In the code above, we are using a lambda expression as our function object,
        and create one that returns the particular kernel function $K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)$.
      </p>
<p>
        Once we have created the operator <code class="computeroutput"><span class="identifier">K</span></code>,
        we can use it within Eigen as if it were a normal matrix. For example, to
        apply <code class="computeroutput"><span class="identifier">K</span></code> to a vector <code class="computeroutput"><span class="identifier">b</span></code>, we could write the following
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span><span class="special">::</span><span class="identifier">LinSpaced</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1.0</span><span class="special">);</span>
<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_1</span> <span class="special">=</span> <span class="identifier">K</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
<p>
        This line of code calculates the following
      </p>
<p>
        $$ c_i = \sum_j^N b_j K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) \text{ for } i=1..N
        $$
      </p>
<p>
        Note that rather then storing all the values of K that are needed for this
        summation, Aboria will instead evaluate these values as they are needed.
        Therefore the memory requirements are only $\mathcal{O}(N)$, rather than
        $\mathcal{O}(N^2)$ for a traditional matrix. However, this requires evaluating
        the kernel function for each pair of particles at a cost of $\mathcal{O}(N^2)$.
        If you wish to calculate this operation approximately, then Aboria can perform
        the same operation using the Fast Multipole Method or Hierarchical Matrices,
        please see subsequent sections for more details on how to do this.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          the <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html" title="Class template MatrixReplacement">Aboria::MatrixReplacement</a></code>
          operator <code class="computeroutput"><span class="identifier">K</span></code> cannot be used,
          for example, in multiplications or additions with other Eigen matrices.
          Thus far, it has only really been tested with matrix-vector multiplication
          and Eigen's iterative solvers
        </p></td></tr>
</table></div>
<p>
        If we wish to perform the same operator, but using a traditional matrix,
        we can use <code class="computeroutput"><span class="identifier">K</span></code>'s <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html#idm45635473792192-bb">Aboria::MatrixReplacement::assemble</a></code>
        member function to fill in a normal Eigen matrix with the values of the kernel
        function $K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)$. This might be useful if
        you wish to perform the same operation repeatedly, or in an iterative solver.
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">MatrixXd</span> <span class="identifier">K_eigen</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">K</span><span class="special">.</span><span class="identifier">assemble</span><span class="special">(</span><span class="identifier">K_eigen</span><span class="special">);</span>

<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_2</span> <span class="special">=</span> <span class="identifier">K_eigen</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.creating_sparse_operators"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_sparse_operators" title="Creating Sparse Operators">Creating
      Sparse Operators</a>
</h3></div></div></div>
<p>
        Is is common in particle-based methods that the kernel function $K$ be non-zero
        only for particle pairs separated by less than a certain radius. In this
        case we have a summation operation like so
      </p>
<p>
        $$ c_i = \sum_j^N b_j K_s(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) \text{ for }
        i=1..N $$
      </p>
<p>
        where $K_s$ is a truncated version of $K$ that is only non-zero for $||\mathbf{dx}_{ij}||&lt;r$,
        where $\mathbf{dx}_{ij}$ is the shortest vector between particles $i$ and
        $j$. Note that for non-periodic systems, this will be $\mathbf{dx}_{ij}=\mathbf{x}_j-\mathbf{x}_i$.
      </p>
<p>
        $$ K_s(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) = \begin{cases} K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j),
        &amp; \text{for } ||\mathbf{dx}_{ij}||&lt;r \\\ 0 &amp; \text{otherwise}.
        \end{cases} $$
      </p>
<p>
        Since the summation is only non-zero for $||\mathbf{dx}_{ij}||&lt;r$, we
        wish to aim for better than $\mathcal{O}(N^2)$ time and combine the sum with
        a spatial search of radius $r$.
      </p>
<p>
        Lets assume that we wish a similar kernel function as before
      </p>
<p>
        $$ K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) = \frac{a_i a_j}{||\mathbf{dx}_{ij}||
        + \epsilon} $$
      </p>
<p>
        We can create the operator <code class="computeroutput"><span class="identifier">K_s</span></code>
        in Aboria like so (setting $r=0.1$ in this case)
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">r</span> <span class="special">=</span> <span class="number">0.1</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">K_s</span> <span class="special">=</span> <span class="identifier">create_sparse_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span>
        <span class="identifier">r</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">i</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">(</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">j</span><span class="special">))</span> <span class="special">/</span> <span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        When applied to a vector, this operator will use the neighbour search of
        the <code class="computeroutput"><span class="identifier">particles</span></code> container to
        perform a neighbour search for all particle pairs where $||\mathbf{dx}_{ij}||&lt;r$.
      </p>
<p>
        Before we can use this operator, we need to make sure that the neighbour
        search for <code class="computeroutput"><span class="identifier">particles</span></code> is initialised.
        By default, the particle container was created using three spatial dimensions,
        so we need to set up a domain from $(0,0,0)$ to $(1,1,1)$ which is not periodic
        in all three directions.
      </p>
<pre class="programlisting"><span class="identifier">double3</span> <span class="identifier">min</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
<span class="identifier">double3</span> <span class="identifier">max</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">bool3</span> <span class="identifier">periodic</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span><span class="identifier">min</span><span class="special">,</span><span class="identifier">max</span><span class="special">,</span><span class="identifier">periodic</span><span class="special">);</span>
</pre>
<p>
        Once this is done, we can then apply the operator to the vector <code class="computeroutput"><span class="identifier">b</span></code> from before
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_3</span> <span class="special">=</span> <span class="identifier">K_s</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
<p>
        Once again, we can write out <code class="computeroutput"><span class="identifier">K_s</span></code>
        to a traditional matrix. This time, we will write out the values of <code class="computeroutput"><span class="identifier">K_s</span></code> to a sparse matrix, so we can still
        obtain an efficient operator
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">SparseMatrix</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">K_s_eigen</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">K_s</span><span class="special">.</span><span class="identifier">assemble</span><span class="special">(</span><span class="identifier">K_s_eigen</span><span class="special">);</span>

<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_4</span> <span class="special">=</span> <span class="identifier">K_s_eigen</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.creating_chebyshev_operators"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_chebyshev_operators" title="Creating Chebyshev Operators">Creating
      Chebyshev Operators</a>
</h3></div></div></div>
<p>
        Lets assume that the kernel function of interest depends only on the particle
        positions
      </p>
<p>
        $$ c_i = \sum_j^N b_j K(\mathbf{x}_i,\mathbf{x}_j) \text{ for } i=1..N $$
      </p>
<p>
        and that we can approximate $K(\mathbf{x}_i,\mathbf{x}_j)$ using interpolation.
        That is, if $w_l(x)$ denotes a set of interpolating functions, then
      </p>
<p>
        $$ K(\mathbf{x}_i,\mathbf{x}_j) \approx \sum_l \sum_m K(\mathbf{x}_l,\mathbf{x}_m)
        w_l(\mathbf{x}_i) w_m(\mathbf{x}_j) $$
      </p>
<p>
        Using this idea, we can use chebyshev interpolation to interpolate $K(\mathbf{x}_i,\mathbf{x}_j)$
        at the chebyshev nodes, leading to an operator that can be applied to a vector
        at a reduced cost. How reduced depends on the number of chebyshev nodes that
        are chosen. A small number of nodes means that the error in the approximation
        grows, while a larger number of nodes means increased computational cost.
      </p>
<p>
        Note that this idea has been published in the following paper, which was
        used as a reference for Aboria's implementation:
      </p>
<p>
        Fong, William, and Eric Darve. "The black-box fast multipole method."
        Journal of Computational Physics 228.23 (2009): 8712-8725.
      </p>
<p>
        One restriction on the kernel function in this context is that it must be
        a smooth function of only position. With this in mind, we will define the
        following kernel function
      </p>
<p>
        $$ K(\mathbf{x}_i,\mathbf{x}_j) = \sqrt{||\mathbf{dx}_{ij}|| + \epsilon}
        $$
      </p>
<p>
        which is the multiquadric radial basis function.
      </p>
<p>
        A kernel operator using this function and chebyshev interpolation can be
        created in Aboria using the <code class="computeroutput"><a class="link" href="../Aboria/create_chebyshev_operator.html" title="Function template create_chebyshev_operator">Aboria::create_chebyshev_operator</a></code>
        function
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">n</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">K_c</span> <span class="special">=</span> <span class="identifier">create_chebyshev_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">n</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
                  <span class="identifier">const_position_reference</span> <span class="identifier">i</span><span class="special">,</span>
                  <span class="identifier">const_position_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">sqrt</span><span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        where <code class="computeroutput"><span class="identifier">n</span></code> sets the number of
        chebyshev nodes in each dimension.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          Once <code class="computeroutput"><span class="identifier">K_c</span></code> is created, it
          assumes that the positions of the particles in <code class="computeroutput"><span class="identifier">particles</span></code>
          do not change. If this is not true, then you can use the function of the
          underlying kernel class <code class="computeroutput"><a class="link" href="../Aboria/KernelChebyshev.html" title="Class template KernelChebyshev">Aboria::KernelChebyshev</a></code>
          to update the positions.
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Aboria's neighbourhood searching does not need to be initialized in this
          case, as no neighbourhood queries are used.
        </p></td></tr>
</table></div>
<p>
        As before, this operator can be applied to an Eigen vector
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_5</span> <span class="special">=</span> <span class="identifier">K_c</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.creating_fast_multipole_method_o"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_fast_multipole_method_o" title="Creating Fast Multipole Method Operators">Creating
      Fast Multipole Method Operators</a>
</h3></div></div></div>
<p>
        One disadvantage of using chebyshev interpolation to construct an operator
        is that it is not valid if the kernel function is discontinuous. This is
        violated by many kernels which contain singularities when $\mathbf{x}_i =
        \mathbf{x}_j$. Also, often large numbers of chebyshev nodes are required,
        which does not reduce the computational cost sufficiently while retaining
        accuracy.
      </p>
<p>
        Another powerful class of methods are based on the Fast Multipole Method,
        which has been also implemented in Aboria. These are valid for kernel functions
        with singularities and which boasts $\mathcal{O}(N)$ complexity if the column
        and row particle sets are identical, and $\mathcal{O}(NlogN)$ if they are
        not.
      </p>
<p>
        Once again, we will use chebyshev interpolation, but now will construct a
        tree data structure using one of Aboria's tree data structures (kd-tree or
        oct-tree). When the kernel operator is applied to a vector, the fast multiplole
        algorithm will be invoked, which leads to traversals up and down the tree,
        using chebyshev interpolation to compress the kernel function for clusters
        of particles that are <span class="emphasis"><em>well separated</em></span>. The interaction
        of particle clusters that are not well separated are calculated directly.
        The details of this are in the following article, which was used as a reference
        for Aboria's implementation:
      </p>
<p>
        Fong, William, and Eric Darve. "The black-box fast multipole method."
        Journal of Computational Physics 228.23 (2009): 8712-8725.
      </p>
<p>
        A kernel operator using the fast multipole method can be created in Aboria
        using the <code class="computeroutput"><a class="link" href="../Aboria/create_fmm_operator.html" title="Function template create_fmm_operator">Aboria::create_fmm_operator</a></code>
        function
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">n2</span> <span class="special">=</span> <span class="number">4</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">K_f</span> <span class="special">=</span> <span class="identifier">create_fmm_operator</span><span class="special">&lt;</span><span class="identifier">n2</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
                  <span class="identifier">const_position_reference</span> <span class="identifier">i</span><span class="special">,</span>
                  <span class="identifier">const_position_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">sqrt</span><span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        where <code class="computeroutput"><span class="identifier">n2</span></code> sets the number
        of chebyshev nodes in each dimension. Note that this is typically much less
        than what is required by the chebyshev operator discussed in the previous
        section.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          the <code class="computeroutput"><a class="link" href="../Aboria/create_fmm_operator.html" title="Function template create_fmm_operator">Aboria::create_fmm_operator</a></code>
          function creates a kernel operator in which the fast multipole algorithm
          is applied completely "on the fly". The fmm can be significantly
          speeded up for static particle positions by storing a hierarchical matrix.
          Please see the next section for more details of how to do this in Aboria.
        </p></td></tr>
</table></div>
<p>
        As before, this operator can be applied to an Eigen vector
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_6</span> <span class="special">=</span> <span class="identifier">K_f</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.creating_hierarchical_matrix_ope"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.creating_hierarchical_matrix_ope" title="Creating Hierarchical Matrix Operators">Creating
      Hierarchical Matrix Operators</a>
</h3></div></div></div>
<p>
        The fast multipole method (fmm) results in multiple tree traversals while
        applying linear operators to the multipole vectors. Rather than calculating
        these linear operators during the algorithm, it is also possible to pre-calculate
        them and store them in a hierarchical H2 matrix. The advantage of this is
        that applying the operator to a vector is much faster, the downside is that
        it assumes that the particle positions do not change.
      </p>
<p>
        A kernel operator which does this can be created using the <code class="computeroutput"><a class="link" href="../Aboria/create_h_idm45635473707296.html" title="Function template create_h2_operator">Aboria::create_h2_operator</a></code>
        function
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">K_h</span> <span class="special">=</span> <span class="identifier">create_h2_operator</span><span class="special">&lt;</span><span class="identifier">n2</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
                  <span class="identifier">const_position_reference</span> <span class="identifier">i</span><span class="special">,</span>
                  <span class="identifier">const_position_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">sqrt</span><span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        As before, this operator can be applied to an Eigen vector
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_7</span> <span class="special">=</span> <span class="identifier">K_h</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
<p>
        As noted earlier, the <code class="computeroutput"><span class="identifier">K_h</span></code>
        operator assumes that the particle positions do not change once it is constructed.
        However, it is a relatively fast operation to change the positions for the
        <span class="bold"><strong>row</strong></span> particle set (this corresponds to the
        target particles in fmm terminology). Thus, a new h2 operator can also be
        constructed from an old h2 operator, using a different set of row particles.
      </p>
<pre class="programlisting"><span class="comment">/*
 * create new particle set
 */</span>
<span class="identifier">particle_type</span> <span class="identifier">particles2</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particles2</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">double3</span><span class="special">(</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">));</span>
<span class="special">}</span>

<span class="comment">/*
 * create h2 operator with new row particles
 */</span>
<span class="keyword">auto</span> <span class="identifier">K_h2</span> <span class="special">=</span> <span class="identifier">create_h2_operator</span><span class="special">(</span><span class="identifier">K_h</span><span class="special">.</span><span class="identifier">get_first_kernel</span><span class="special">(),</span><span class="identifier">particles2</span><span class="special">);</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.block_operators"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.block_operators" title="Block Operators">Block
      Operators</a>
</h3></div></div></div>
<p>
        It is common that you would like to compose operators in a tiled or block
        format, and Aboria provides a functionality to do this using the <code class="computeroutput"><a class="link" href="../Aboria/create_block_operator.html" title="Function template create_block_operator">Aboria::create_block_operator</a></code>.
      </p>
<p>
        Let us assume that we wish to compose the two operators <code class="computeroutput"><span class="identifier">K</span></code>
        and <code class="computeroutput"><span class="identifier">K_s</span></code> from before, and
        want to perform the following combined operator
      </p>
<p>
        $$ \begin{align} e_i &amp;= \sum_j^N d_j K_s(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)
        \text{ for } i=1...N \\ e_{i+N} &amp;= \sum_j^N d_{j+N} K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)
        \text{ for } i=1...N \end{align} $$
      </p>
<p>
        where $e_i$ and $d_j$ are elements of vectors $\mathbf{e}$ and $\mathbf{d}$
        of size $2N$. Using matrix notation, and using $\mathbf{K}$ and $\mathbf{K}_s$
        to represent the operators <code class="computeroutput"><span class="identifier">K</span></code>
        and <code class="computeroutput"><span class="identifier">K_s</span></code>, this is equivalent
        to
      </p>
<p>
        $$ \mathbf{e} = \begin{pmatrix} \mathbf{K}_s &amp; 0 \\\ 0 &amp; \mathbf{K}
        \end{pmatrix} \mathbf{d} $$
      </p>
<p>
        We first need operators representing the zero matrices in the upper right
        and lower left corners of the block operator. We create these in Aboria like
        so
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">Zero</span> <span class="special">=</span> <span class="identifier">create_zero_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">);</span>
</pre>
<p>
        and then we can create the block operator <code class="computeroutput"><span class="identifier">Full</span></code>
        like so
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">Full</span> <span class="special">=</span> <span class="identifier">create_block_operator</span><span class="special">&lt;</span><span class="number">2</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span>
                 <span class="identifier">K_s</span> <span class="special">,</span> <span class="identifier">Zero</span><span class="special">,</span>
                <span class="identifier">Zero</span> <span class="special">,</span>  <span class="identifier">K</span>
        <span class="special">);</span>
</pre>
<p>
        Finally we can create vectors <code class="computeroutput"><span class="identifier">e</span></code>
        and <code class="computeroutput"><span class="identifier">d</span></code> and apply the block
        operator
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">d</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">d</span><span class="special">.</span><span class="identifier">head</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span><span class="special">::</span><span class="identifier">LinSpaced</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1.0</span><span class="special">);</span>
<span class="identifier">d</span><span class="special">.</span><span class="identifier">tail</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span><span class="special">::</span><span class="identifier">LinSpaced</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1.0</span><span class="special">);</span>

<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">e</span> <span class="special">=</span> <span class="identifier">Full</span><span class="special">*</span><span class="identifier">d</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.evaluating_and_solving_kernel_op.iterative_solvers"></a><a class="link" href="evaluating_and_solving_kernel_op.html#aboria.evaluating_and_solving_kernel_op.iterative_solvers" title="Iterative Solvers">Iterative
      Solvers</a>
</h3></div></div></div>
<p>
        The <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html" title="Class template MatrixReplacement">Aboria::MatrixReplacement</a></code>
        class can multiply other Eigen vectors, and can be used in Eigen's iterative
        solvers. Both <code class="computeroutput"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">IdentityPreconditioner</span></code> and <code class="computeroutput"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">DiagonalPreconditioner</span></code> preconditioners
        are supported. Below is an example of how to use Eigen's GMRES iterative
        solver to solve the equation
      </p>
<p>
        $$\mathbf{c} = \mathbf{K} \mathbf{h}$$
      </p>
<p>
        for input vector $\mathbf{h}$.
      </p>
<p>
        We can simply pass the dense operator <code class="computeroutput"><span class="identifier">K</span></code>
        to Eigen's GMRES iterative solver like so
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">GMRES</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">K</span><span class="special">),</span>
    <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">DiagonalPreconditioner</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">gmres_matrix_free</span><span class="special">;</span>
<span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">setMaxIterations</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">set_restart</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">compute</span><span class="special">(</span><span class="identifier">K</span><span class="special">);</span>
<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">h_1</span> <span class="special">=</span> <span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">solve</span><span class="special">(</span><span class="identifier">c_1</span><span class="special">);</span>
</pre>
<p>
        This will solve the equation in a matrix-free fashion. Alternatively, we
        can use the normal matrix <code class="computeroutput"><span class="identifier">K_eigen</span></code>
        that we assembled previously to solve the equation
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">GMRES</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">K_eigen</span><span class="special">),</span>
     <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">DiagonalPreconditioner</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">gmres_matrix</span><span class="special">;</span>
 <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">setMaxIterations</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">);</span>
 <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">set_restart</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
 <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">compute</span><span class="special">(</span><span class="identifier">K_eigen</span><span class="special">);</span>
 <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">h_2</span> <span class="special">=</span> <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">solve</span><span class="special">(</span><span class="identifier">c_1</span><span class="special">);</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015-2017 Martin Robinson</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="neighbourhood_searching.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="symbolic_expressions.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
